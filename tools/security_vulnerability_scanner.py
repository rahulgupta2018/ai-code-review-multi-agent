"""
Security Vulnerability Scanner Tool Implementation for ADK Code Review System.

This tool provides comprehensive security vulnerability detection and OWASP Top 10 analysis.
"""

import time
import re
from typing import Dict, Any, List, Optional

from google.adk.tools.tool_context import ToolContext


def scan_security_vulnerabilities(tool_context: ToolContext) -> Dict[str, Any]:
    """
    Comprehensive security vulnerability scanner following OWASP Top 10.
    
    Args:
        tool_context: ADK ToolContext containing session state and parameters
        
    Returns:
        dict: Security analysis results with vulnerability findings and risk assessment
    """
    execution_start = time.time()
    
    try:
        # Get code from tool context
        code = tool_context.state.get('code', '')
        language = tool_context.state.get('language', 'python')
        file_path = tool_context.state.get('file_path', 'unknown')
        
        # Check parameters if not in state
        if not code and hasattr(tool_context, 'parameters'):
            code = getattr(tool_context, 'parameters', {}).get('code', '')
            language = getattr(tool_context, 'parameters', {}).get('language', 'python')
            file_path = getattr(tool_context, 'parameters', {}).get('file_path', 'unknown')
        
        if not code:
            return {
                'status': 'error',
                'error_message': 'No code provided for security analysis',
                'tool_name': 'scan_security_vulnerabilities'
            }
        
        # Perform comprehensive security analysis
        security_result = {
            'status': 'success',
            'tool_name': 'scan_security_vulnerabilities',
            'file_path': file_path,
            'language': language,
            'analysis_type': 'security_vulnerability_scan',
            'owasp_top_10_analysis': {
                'injection_vulnerabilities': _scan_injection_vulnerabilities(code, language),
                'broken_authentication': _scan_authentication_issues(code, language),
                'sensitive_data_exposure': _scan_data_exposure(code, language),
                'xml_external_entities': _scan_xxe_vulnerabilities(code, language),
                'broken_access_control': _scan_access_control(code, language),
                'security_misconfiguration': _scan_security_config(code, language),
                'cross_site_scripting': _scan_xss_vulnerabilities(code, language),
                'insecure_deserialization': _scan_deserialization(code, language),
                'vulnerable_components': _scan_vulnerable_components(code, language),
                'insufficient_logging': _scan_logging_issues(code, language)
            },
            'vulnerability_summary': {
                'total_vulnerabilities': 0,
                'critical_vulnerabilities': 0,
                'high_vulnerabilities': 0,
                'medium_vulnerabilities': 0,
                'low_vulnerabilities': 0
            },
            'risk_assessment': _assess_security_risk(code, language),
            'compliance_check': _check_security_compliance(code, language),
            'recommendations': _generate_security_recommendations(code, language),
            'timestamp': time.time()
        }
        
        # Count vulnerabilities by severity
        all_vulnerabilities = []
        for category, vulns in security_result['owasp_top_10_analysis'].items():
            all_vulnerabilities.extend(vulns)
        
        for vuln in all_vulnerabilities:
            security_result['vulnerability_summary']['total_vulnerabilities'] += 1
            severity = vuln.get('severity', 'low')
            security_result['vulnerability_summary'][f'{severity}_vulnerabilities'] += 1
        
        execution_time = time.time() - execution_start
        security_result['execution_time_seconds'] = execution_time
        
        # Store results in session state
        current_analysis = tool_context.state.get('security_analysis', {})
        current_analysis[file_path] = security_result
        tool_context.state['security_analysis'] = current_analysis
        
        # Update analysis progress
        analysis_progress = tool_context.state.get('analysis_progress', {})
        analysis_progress['security_scan_completed'] = True
        analysis_progress['security_scan_timestamp'] = time.time()
        tool_context.state['analysis_progress'] = analysis_progress
        
        return security_result
        
    except Exception as e:
        execution_time = time.time() - execution_start
        error_result = {
            'status': 'error',
            'tool_name': 'scan_security_vulnerabilities',
            'error_message': str(e),
            'error_type': type(e).__name__,
            'execution_time_seconds': execution_time
        }
        
        tool_context.state['security_analysis_error'] = error_result
        return error_result


def _scan_injection_vulnerabilities(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for injection vulnerabilities (OWASP #1)."""
    vulnerabilities = []
    
    # SQL Injection patterns
    sql_patterns = [
        (r'execute\s*\([^)]*%s[^)]*\)', 'SQL injection via string formatting', 'critical'),
        (r'query\s*[\+\&]\s*["\'][^"\']*["\']', 'SQL injection via string concatenation', 'high'),
        (r'cursor\.execute\s*\([^)]*\+[^)]*\)', 'SQL injection in cursor.execute', 'critical'),
        (r'WHERE\s+[^=]*=\s*["\'][^"\']*\+', 'SQL injection in WHERE clause', 'high'),
    ]
    
    for pattern, message, severity in sql_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE)
        for match in matches:
            vulnerabilities.append({
                'type': 'injection_vulnerability',
                'subtype': 'sql_injection',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group()[:100] + '...' if len(match.group()) > 100 else match.group(),
                'cwe_id': 'CWE-89'
            })
    
    # NoSQL Injection patterns
    nosql_patterns = [
        (r'\$where\s*:', 'NoSQL injection via $where operator', 'high'),
        (r'eval\s*\([^)]*user', 'NoSQL injection via eval', 'critical'),
    ]
    
    for pattern, message, severity in nosql_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE)
        for match in matches:
            vulnerabilities.append({
                'type': 'injection_vulnerability',
                'subtype': 'nosql_injection',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group(),
                'cwe_id': 'CWE-943'
            })
    
    return vulnerabilities


def _scan_authentication_issues(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for broken authentication (OWASP #2)."""
    vulnerabilities = []
    
    # Weak authentication patterns
    auth_patterns = [
        (r'password\s*==\s*["\'][^"\']*["\']', 'Hardcoded password comparison', 'high'),
        (r'session\[\s*["\']user["\']\s*\]\s*=', 'Direct session manipulation', 'medium'),
        (r'jwt\.decode\([^,]*,\s*verify=False', 'JWT signature verification disabled', 'critical'),
        (r'md5\([^)]*password', 'Weak password hashing (MD5)', 'high'),
    ]
    
    for pattern, message, severity in auth_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE)
        for match in matches:
            vulnerabilities.append({
                'type': 'authentication_vulnerability',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group(),
                'cwe_id': 'CWE-287'
            })
    
    return vulnerabilities


def _scan_data_exposure(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for sensitive data exposure (OWASP #3)."""
    vulnerabilities = []
    
    # Sensitive data patterns
    exposure_patterns = [
        (r'print\([^)]*password[^)]*\)', 'Password printed to output', 'high'),
        (r'log\.[^(]*\([^)]*secret[^)]*\)', 'Secret logged', 'medium'),
        (r'api_key\s*=\s*["\'][^"\']*["\']', 'Hardcoded API key', 'high'),
        (r'private_key\s*=\s*["\']', 'Hardcoded private key', 'critical'),
    ]
    
    for pattern, message, severity in exposure_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE)
        for match in matches:
            vulnerabilities.append({
                'type': 'data_exposure_vulnerability',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group()[:50] + '...' if len(match.group()) > 50 else match.group(),
                'cwe_id': 'CWE-200'
            })
    
    return vulnerabilities


def _scan_xxe_vulnerabilities(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for XML External Entity vulnerabilities (OWASP #4)."""
    vulnerabilities = []
    
    xxe_patterns = [
        (r'XMLParser\([^)]*resolve_entities=True', 'XXE: XML parser with entity resolution enabled', 'high'),
        (r'etree\.parse\([^)]*\)', 'Potentially unsafe XML parsing', 'medium'),
    ]
    
    for pattern, message, severity in xxe_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE)
        for match in matches:
            vulnerabilities.append({
                'type': 'xxe_vulnerability',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group(),
                'cwe_id': 'CWE-611'
            })
    
    return vulnerabilities


def _scan_access_control(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for broken access control (OWASP #5)."""
    vulnerabilities = []
    
    access_patterns = [
        (r'@app\.route\([^)]*\)\s*def\s+[^(]*\([^)]*\):\s*(?!.*@)', 'Route without authorization check', 'medium'),
        (r'os\.system\([^)]*user', 'Command injection via user input', 'critical'),
        (r'subprocess\.[^(]*\([^)]*user', 'Command execution with user input', 'high'),
    ]
    
    for pattern, message, severity in access_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE | re.DOTALL)
        for match in matches:
            vulnerabilities.append({
                'type': 'access_control_vulnerability',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group()[:100] + '...' if len(match.group()) > 100 else match.group(),
                'cwe_id': 'CWE-264'
            })
    
    return vulnerabilities


def _scan_security_config(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for security misconfiguration (OWASP #6)."""
    vulnerabilities = []
    
    config_patterns = [
        (r'DEBUG\s*=\s*True', 'Debug mode enabled in production', 'medium'),
        (r'ssl_verify\s*=\s*False', 'SSL verification disabled', 'high'),
        (r'CORS\([^)]*origins=\*', 'CORS configured to allow all origins', 'medium'),
    ]
    
    for pattern, message, severity in config_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE)
        for match in matches:
            vulnerabilities.append({
                'type': 'security_misconfiguration',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group(),
                'cwe_id': 'CWE-16'
            })
    
    return vulnerabilities


def _scan_xss_vulnerabilities(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for Cross-Site Scripting vulnerabilities (OWASP #7)."""
    vulnerabilities = []
    
    xss_patterns = [
        (r'innerHTML\s*=\s*[^;]*user', 'Potential XSS via innerHTML', 'high'),
        (r'document\.write\([^)]*user', 'Potential XSS via document.write', 'high'),
        (r'render_template_string\([^)]*user', 'Server-side template injection', 'critical'),
    ]
    
    for pattern, message, severity in xss_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE)
        for match in matches:
            vulnerabilities.append({
                'type': 'xss_vulnerability',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group(),
                'cwe_id': 'CWE-79'
            })
    
    return vulnerabilities


def _scan_deserialization(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for insecure deserialization (OWASP #8)."""
    vulnerabilities = []
    
    deser_patterns = [
        (r'pickle\.loads?\([^)]*user', 'Unsafe pickle deserialization', 'critical'),
        (r'yaml\.load\([^)]*user[^)]*\)', 'Unsafe YAML deserialization', 'high'),
        (r'eval\([^)]*user', 'Code execution via eval', 'critical'),
    ]
    
    for pattern, message, severity in deser_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE)
        for match in matches:
            vulnerabilities.append({
                'type': 'deserialization_vulnerability',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group(),
                'cwe_id': 'CWE-502'
            })
    
    return vulnerabilities


def _scan_vulnerable_components(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for vulnerable components (OWASP #9)."""
    vulnerabilities = []
    
    # Check for known vulnerable imports/dependencies
    vulnerable_patterns = [
        (r'import requests[^a-zA-Z].*# version < 2\.20', 'Vulnerable requests library', 'high'),
        (r'from flask import.*# version < 1\.0', 'Vulnerable Flask version', 'medium'),
        (r'import urllib3[^a-zA-Z].*disable_warnings', 'urllib3 warnings disabled', 'medium'),
    ]
    
    for pattern, message, severity in vulnerable_patterns:
        matches = re.finditer(pattern, code, re.IGNORECASE)
        for match in matches:
            vulnerabilities.append({
                'type': 'vulnerable_component',
                'message': message,
                'severity': severity,
                'line': code[:match.start()].count('\n') + 1,
                'evidence': match.group(),
                'cwe_id': 'CWE-1104'
            })
    
    return vulnerabilities


def _scan_logging_issues(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for insufficient logging (OWASP #10)."""
    vulnerabilities = []
    
    # Check for lack of security logging
    if not re.search(r'log\.[^(]*\([^)]*security[^)]*\)', code, re.IGNORECASE):
        if 'login' in code.lower() or 'auth' in code.lower():
            vulnerabilities.append({
                'type': 'insufficient_logging',
                'message': 'Authentication/authorization code lacks security logging',
                'severity': 'medium',
                'line': 1,
                'evidence': 'No security logging detected',
                'cwe_id': 'CWE-778'
            })
    
    return vulnerabilities


def _assess_security_risk(code: str, language: str) -> Dict[str, Any]:
    """Assess overall security risk level."""
    risk_factors = {
        'sql_injection_risk': len(re.findall(r'execute\s*\([^)]*%', code, re.IGNORECASE)),
        'xss_risk': len(re.findall(r'innerHTML|document\.write', code, re.IGNORECASE)),
        'auth_bypass_risk': len(re.findall(r'verify=False|ssl_verify=False', code, re.IGNORECASE)),
        'code_execution_risk': len(re.findall(r'eval\(|exec\(|os\.system', code, re.IGNORECASE)),
        'secret_exposure_risk': len(re.findall(r'password|api_key|secret', code, re.IGNORECASE)),
    }
    
    total_risk_score = sum(risk_factors.values())
    
    if total_risk_score >= 10:
        risk_level = 'critical'
    elif total_risk_score >= 5:
        risk_level = 'high'
    elif total_risk_score >= 2:
        risk_level = 'medium'
    else:
        risk_level = 'low'
    
    return {
        'overall_risk_level': risk_level,
        'risk_score': total_risk_score,
        'risk_factors': risk_factors,
        'security_grade': _get_security_grade(total_risk_score)
    }


def _check_security_compliance(code: str, language: str) -> Dict[str, Any]:
    """Check compliance with security standards."""
    compliance_checks = {
        'owasp_compliance': 'partial',
        'pci_dss_indicators': _check_pci_compliance(code),
        'gdpr_indicators': _check_gdpr_compliance(code),
        'security_headers': _check_security_headers(code),
        'input_validation': _check_input_validation(code)
    }
    
    return compliance_checks


def _check_pci_compliance(code: str) -> List[str]:
    """Check for PCI DSS compliance indicators."""
    indicators = []
    if 'credit_card' in code.lower() or 'card_number' in code.lower():
        indicators.append('Credit card data handling detected')
    if 'encrypt' in code.lower():
        indicators.append('Encryption usage detected')
    return indicators


def _check_gdpr_compliance(code: str) -> List[str]:
    """Check for GDPR compliance indicators."""
    indicators = []
    if 'personal_data' in code.lower() or 'user_data' in code.lower():
        indicators.append('Personal data processing detected')
    if 'consent' in code.lower():
        indicators.append('Consent handling detected')
    return indicators


def _check_security_headers(code: str) -> List[str]:
    """Check for security headers implementation."""
    headers = []
    if 'X-Frame-Options' in code:
        headers.append('X-Frame-Options header found')
    if 'Content-Security-Policy' in code:
        headers.append('CSP header found')
    return headers


def _check_input_validation(code: str) -> bool:
    """Check if input validation is implemented."""
    validation_patterns = [
        r'validate\(',
        r'sanitize\(',
        r'escape\(',
        r'filter\(',
    ]
    
    for pattern in validation_patterns:
        if re.search(pattern, code, re.IGNORECASE):
            return True
    return False


def _get_security_grade(risk_score: int) -> str:
    """Get security grade based on risk score."""
    if risk_score == 0:
        return 'A'
    elif risk_score <= 2:
        return 'B'
    elif risk_score <= 5:
        return 'C'
    elif risk_score <= 10:
        return 'D'
    else:
        return 'F'


def _generate_security_recommendations(code: str, language: str) -> List[str]:
    """Generate security recommendations."""
    recommendations = []
    
    if 'password' in code.lower():
        recommendations.append("Use secure password hashing (bcrypt, scrypt, or Argon2)")
        recommendations.append("Store sensitive data in environment variables or secure vaults")
    
    if 'api_key' in code.lower():
        recommendations.append("Use environment variables for API keys and secrets")
    
    if re.search(r'execute\s*\([^)]*%', code, re.IGNORECASE):
        recommendations.append("Use parameterized queries to prevent SQL injection")
    
    if 'eval(' in code or 'exec(' in code:
        recommendations.append("Avoid using eval() and exec() - use safer alternatives")
    
    if 'ssl_verify=False' in code.lower():
        recommendations.append("Enable SSL certificate verification")
    
    if not re.search(r'log\.[^(]*\([^)]*security', code, re.IGNORECASE):
        recommendations.append("Implement security event logging for monitoring")
    
    if not recommendations:
        recommendations.append("No critical security issues detected - maintain current security practices")
    
    return recommendations